La diferencia principal entre **usar el patrón Factory Method** (con `CreateDocumentObject`) y **crear directamente
clases que hereden de `Document`** radica en la **flexibilidad** y el **desacoplamiento** que obtienes al emplear el
patrón de diseño. A continuación, te explico por qué usar un Factory Method podría ser mejor en ciertos contextos,
comparado con heredar directamente de `Document`:

### 1. **Desacoplamiento entre la creación y el uso de objetos**
   - **Con Factory Method**: El código cliente (quien usa los documentos) **no necesita conocer las clases
   concretas** (como `CSV`, `JSON`, etc.) que está utilizando. El cliente solo conoce la clase abstracta
   `CreateDocumentObject`, que se encarga de crear el documento apropiado.

     - **Ventaja**: Si en el futuro necesitas cambiar la forma en que creas un documento (por ejemplo, cambiar
     el backend de lectura o escritura de documentos CSV), lo puedes hacer en la clase `CreateCSV`, sin modificar
      el código que usa esos documentos.

   - **Sin Factory Method (herencia directa de `Document`)**: El cliente tendría que instanciar directamente las
   clases concretas (`CSV`, `JSON`, etc.). Esto implica que el código cliente debe saber exactamente qué clase
   instanciar dependiendo del tipo de documento.

     - **Desventaja**: Si en algún momento necesitas cambiar cómo se crea un documento, tendrías que hacer
     cambios en el código cliente. Esto va en contra del principio **abierto/cerrado (OCP)**, ya que tendrías
     que modificar el código existente.

### 2. **Escalabilidad y mantenimiento**
   - **Con Factory Method**: Si decides agregar nuevos tipos de documentos en el futuro (por ejemplo, `Excel`,
    `XML`), solo necesitas registrar esos nuevos formatos en la clase `DocumentFactory`, sin tocar el código de
     las clases o el código cliente que usa documentos. Además, puedes hacerlo de manera centralizada, desde una
      sola fábrica.

     - **Ventaja**: Tu código es más escalable porque agregar nuevas funcionalidades (nuevos tipos de documentos)
      no requiere modificar el código existente, solo lo extiendes.

   - **Sin Factory Method**: Cada vez que agregas un nuevo tipo de documento, tendrías que modificar el código
   cliente para que sepa cómo crear instancias de esa nueva clase. Esto puede ser tedioso y propenso a errores
   si hay muchas partes del código que utilizan documentos.

     - **Desventaja**: Esto no es escalable, ya que la lógica de creación de objetos está dispersa en todo el
     código cliente, y cualquier cambio requeriría actualizaciones en múltiples lugares.

### 3. **Cumplimiento de SOLID**
   - **Con Factory Method**:
     - **Principio de responsabilidad única (SRP)**: Separas claramente las responsabilidades: la creación de los
     documentos está en las clases creadoras (`CreateCSV`, `CreateJSON`), y la lógica del documento está en las
     clases `CSV`, `JSON`, etc. Esto facilita el mantenimiento, ya que si hay cambios en cómo se crea el documento,
      no tienes que modificar la clase `Document`.

     - **Principio abierto/cerrado (OCP)**: No necesitas modificar clases existentes para soportar nuevos formatos
      de documentos; simplemente creas una nueva clase creadora que herede de `CreateDocumentObject`.

   - **Sin Factory Method**:
     - **SRP violado**: El código que usa los documentos también sería responsable de instanciarlos, lo que mezcla
      responsabilidades (creación y uso) en un solo lugar.

     - **OCP violado**: Si agregas nuevos tipos de documentos, tendrías que modificar el código cliente para que
     sepa cómo crear esos nuevos tipos, lo que va en contra del principio abierto/cerrado.

### 4. **Testing más fácil**
   - **Con Factory Method**: Al separar la creación de objetos en una clase distinta, puedes **testear las clases
    de creación de documentos por separado**. Además, el uso de interfaces y clases abstractas (como
    `CreateDocumentObject`) hace más fácil mockear o simular diferentes comportamientos en los tests, sin necesidad
     de modificar el código real.

   - **Sin Factory Method**: Al no tener un desacoplamiento claro entre la creación y el uso de los documentos,
   el testing puede volverse más complicado, ya que el cliente está más estrechamente acoplado a las clases
   concretas de los documentos.

### 5. **Dinamismo**
   - **Con Factory Method**: Puedes hacer el código dinámico, como el caso que planteas donde decides qué tipo
    de documento crear basado en la extensión del archivo. Esto es posible gracias a la **DocumentFactory**,
    que delega la responsabilidad de crear el documento apropiado sin que el cliente tenga que saberlo.

   - **Sin Factory Method**: Tendrías que utilizar condicionales (`if` o `switch`) en el código cliente para
   verificar la extensión del archivo y crear manualmente la clase correspondiente. Esto no es tan dinámico
   ni escalable, y hace que el código sea más rígido y difícil de mantener.


### **Ejemplo Sin Factory Method:**
Si eliminamos el Factory Method y hacemos que las clases hereden directamente de `Document`, el código cliente
tendría que manejar manualmente la creación de objetos de acuerdo a la extensión del archivo, algo así:

```python
def get_document(filepath):
    extension = filepath.split('.')[-1]
    if extension == 'csv':
        return CSV(filepath)
    elif extension == 'json':
        return JSON(filepath)
    else:
        raise ValueError(f"No document handler for extension: {extension}")

# Uso en el código cliente
doc = get_document('data/raw/iris.csv')
df = doc.readDoc()
doc.writeDoc('data/output/iris.csv')
```

- **Desventaja**: Este enfoque obliga al código cliente a tomar decisiones sobre qué clase instanciar (violando SRP)
 y a modificar el código cada vez que se agregue un nuevo tipo de documento (violando OCP). Esto también puede hacer
  que el código sea más difícil de mantener y escalar a medida que se añaden más tipos de documentos.


### **Conclusión**:
- **Usar el Factory Method** es mejor en escenarios donde buscas flexibilidad, escalabilidad y un diseño desacoplado.
 Te permite cumplir con principios de diseño (SOLID), facilita la mantenibilidad y hace que tu sistema sea extensible
  sin cambiar el código existente.

- **No usar Factory Method** puede ser suficiente si tu sistema es muy pequeño, no va a escalar y no necesitas
agregar nuevos tipos de documentos. Pero en sistemas más complejos, donde esperas trabajar con múltiples tipos de
documentos o cambiar la lógica de creación en el futuro, el Factory Method es una mejor opción.